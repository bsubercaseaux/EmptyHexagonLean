import Geo.Definitions.Point
import Geo.Definitions.WBPoints
import Geo.Orientations
import Geo.PointsToWB.TMatrix
import Geo.PointsToWB.Affine

/-! We define `PtInTriangle`, `œÉPtInTriangle`,
and show their equivalence for points in general position. -/

namespace Geo
open Point
open List Orientation

noncomputable section
open Classical

/-- `PtInTriangle a p q r` means that `a` is in the triangle `pqr`,
possibly on the boundary. -/
def PtInTriangle (a : Point) (p q r : Point) : Prop :=
  a ‚àà convexHull ‚Ñù {p, q, r}

lemma xBounded_of_PtInTriangle {x a b c : Point} :
    Sorted‚ÇÉ a b c ‚Üí PtInTriangle x a b c ‚Üí a.x ‚â§ x.x ‚àß x.x ‚â§ c.x := by
  unfold PtInTriangle
  intro sorted tri
  let S := { p : Point | a.x ‚â§ p.x } ‚à© { p : Point | p.x ‚â§ c.x }
  have cvxS : Convex ‚Ñù S :=
    Convex.inter
      (convex_halfspace_ge ‚ü®fun _ _ => rfl, fun _ _ => rfl‚ü© a.x)
      (convex_halfspace_le ‚ü®fun _ _ => rfl, fun _ _ => rfl‚ü© c.x)
  have abcS : {a, b, c} ‚äÜ S := by
    intro x hx
    simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx
    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]
    rcases hx with rfl | rfl | rfl
    . exact ‚ü®le_rfl, le_of_lt <| sorted.h‚ÇÅ.trans sorted.h‚ÇÇ‚ü©
    . exact ‚ü®le_of_lt sorted.h‚ÇÅ, le_of_lt sorted.h‚ÇÇ‚ü©
    . exact ‚ü®le_of_lt <| sorted.h‚ÇÅ.trans sorted.h‚ÇÇ, le_rfl‚ü©
  have : x ‚àà S := convexHull_min abcS cvxS tri
  simpa only [Set.mem_inter_iff, Set.mem_setOf_eq] using this

theorem PtInTriangle.perm‚ÇÅ : PtInTriangle a p q r ‚Üí PtInTriangle a q p r := by
  unfold PtInTriangle
  intro
  have : ({q, p, r} : Set Point) = {p, q, r} := Set.insert_comm q p {r}
  rwa [this]

theorem PtInTriangle.perm‚ÇÇ : PtInTriangle a p q r ‚Üí PtInTriangle a p r q := by
  unfold PtInTriangle
  intro
  have : ({r, q} : Set Point) = {q, r} := Set.pair_comm r q
  have : ({p, r, q} : Set Point) = {p, q, r} := congrArg (insert p) this
  rwa [this]

/-- `œÉPtInTriangle a p q r` means that `a` is in the triangle `pqr` strictly,
i.e., not on the boundary. -/
def œÉPtInTriangle (a p q r : Point) : Prop :=
  œÉ p q a = œÉ p q r ‚àß
  œÉ p r a = œÉ p r q ‚àß
  œÉ q r a = œÉ q r p

theorem not_mem_œÉPtInTriangle {p q r : Point} :
    InGeneralPosition‚ÇÉ p q r ‚Üí ¬¨œÉPtInTriangle q p q r := by
  intro h ‚ü®h', _, _‚ü©
  rw [œÉ_self‚ÇÅ] at h'
  have := h.œÉ_ne
  rw [‚Üê h'] at this
  contradiction

theorem œÉPtInTriangle.perm‚ÇÅ : œÉPtInTriangle a p q r ‚Üí œÉPtInTriangle a q p r := by
  unfold œÉPtInTriangle
  intro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
  conv in œÉ q p a => rw [œÉ_perm‚ÇÅ]
  conv in œÉ q p r => rw [œÉ_perm‚ÇÅ]
  simp [*]

theorem œÉPtInTriangle.perm‚ÇÇ : œÉPtInTriangle a p q r ‚Üí œÉPtInTriangle a p r q := by
  unfold œÉPtInTriangle
  intro ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
  conv in œÉ r q a => rw [œÉ_perm‚ÇÅ]
  conv in œÉ r q p => rw [œÉ_perm‚ÇÅ]
  simp [*]

theorem œÉPtInTriangle.gp‚ÇÑ_of_gp‚ÇÉ :
    InGeneralPosition‚ÇÉ p q r ‚Üí œÉPtInTriangle a p q r ‚Üí InGeneralPosition‚ÇÑ a p q r := by
  intro gp ‚ü®tri‚ÇÅ, tri‚ÇÇ, tri‚ÇÉ‚ü©
  constructor <;> rw [InGeneralPosition‚ÇÉ.iff_ne_collinear] at gp ‚ä¢
  . rw [œÉ_perm‚ÇÅ, œÉ_perm‚ÇÇ, neg_neg]
    intro h
    rw [h] at tri‚ÇÅ
    rw [‚Üê tri‚ÇÅ] at gp
    contradiction
  . rw [œÉ_perm‚ÇÅ, œÉ_perm‚ÇÇ, neg_neg]
    intro h
    rw [h, œÉ_perm‚ÇÇ] at tri‚ÇÇ
    have tri‚ÇÇ := congrArg (-¬∑) tri‚ÇÇ
    simp only [neg_neg] at tri‚ÇÇ
    rw [‚Üê tri‚ÇÇ] at gp
    contradiction
  . rw [œÉ_perm‚ÇÅ, œÉ_perm‚ÇÇ, neg_neg]
    intro h
    rw [h, œÉ_perm‚ÇÇ, œÉ_perm‚ÇÅ, neg_neg] at tri‚ÇÉ
    rw [‚Üê tri‚ÇÉ] at gp
    contradiction
  . assumption

/-! ## Proof of equivalence between œÉPtInTriangle and PtInTriangle -/

-- TODO: deduplicate with PointsToWB.Affine
noncomputable def rotateTranslate (p : Point) (Œ∏ : ‚Ñù) (tx ty : ‚Ñù) : Point :=
  ![p 0 * (Real.cos Œ∏) - p 1 * (Real.sin Œ∏) + tx, p 0 * (Real.sin Œ∏) + p 1 * (Real.cos Œ∏) + ty]

def translateMap (p : Point) : Point ‚Üí·µÉ[‚Ñù] Point :=
  AffineMap.const ‚Ñù Point p + AffineMap.id ‚Ñù Point

theorem translateMap_apply (x : Point) : translateMap p x = p + x := by
  simp [translateMap]

def rotateTranslateMap (Œ∏ : ‚Ñù) (p : Point) : Point ‚Üí·µÉ[‚Ñù] Point :=
  AffineMap.comp (translateMap p) (rotationMap Œ∏).toAffineMap

theorem injective_rotateTranslateMap (Œ∏ : ‚Ñù) (p : Point) : Function.Injective (rotateTranslateMap Œ∏ p) := by
  unfold rotateTranslateMap
  apply Function.Injective.comp (g := translateMap p)
  . exact fun x y h => add_left_cancel h
  . simp [injective_rotationMap]

lemma pt_transform_translateMap (p  t: Point) : pt_transform (translation_matrix t.x t.y) p = translateMap t p := by
  ext <;> simp [pt_transform, translation_matrix, Point.x, Point.y, vec_to_pt, pt_to_vec];
  ring_nf
  rw [translateMap_apply]
  simp
  rw [Matrix.mul_apply]
  rw [Fin.sum_univ_three]
  simp [add_comm]
  rw [Matrix.mul_apply]
  rw [Fin.sum_univ_three]
  simp
  rw [translateMap_apply]
  simp [add_comm]

noncomputable def rotate (Œ∏ : ‚Ñù) (p : Point) : Point :=
  ![p 0 * (Real.cos Œ∏) - p 1 * (Real.sin Œ∏), p 0 * (Real.sin Œ∏) + p 1 * (Real.cos Œ∏)]

noncomputable def rotateTranslateSet (S : Set Point) (Œ∏ : ‚Ñù) (tx ty : ‚Ñù) : Set Point :=
  {rotateTranslate p Œ∏ tx ty | p ‚àà S}

theorem rotateTranslateTransform (Œ∏ : ‚Ñù) (t p : Point) :
    (rotateTranslateMap Œ∏ t p) = pt_transform ((translation_matrix t.x t.y)*(Matrix.rotateByAffine Œ∏)) p := by
  rw [pt_transform_by_prod]
  unfold rotateTranslateMap
  simp
  rw [‚Üêpt_transform_rotateByAffine]
  rw [pt_transform_translateMap]
  unfold Matrix.rotateByAffine
  rfl

lemma rotateTranslateTMatrix (Œ∏ : ‚Ñù) (t : Point) :
    TMatrix (translation_matrix t.x t.y * Matrix.rotateByAffine Œ∏) := by
  have : TMatrix (translation_matrix t.x t.y) := by {
    exact translation_transform t.x t.y
  }
  exact TMatrix.mul this (TMatrix.rotateByAffine Œ∏)

def ptInsideHalfPlaneCCW (p q a : Point) : Prop :=
  (œÉ p q a = .CCW) ‚à® (œÉ p q a = .Collinear)

def halfPlaneCCW (p q : Point) : Set Point :=
  {a | ptInsideHalfPlaneCCW p q a}

theorem œÉ_CCW_iff_pos_det : œÉ p q r = .CCW ‚Üî matrix_det p q r > 0 := by
  rw [œÉ, ofReal_eq_ccw]

theorem œÉ_CW_iff_neg_det : œÉ p q r = .CW ‚Üî matrix_det p q r < 0 := by
  rw [œÉ, ofReal_eq_cw]

theorem œÉ_Co_iff_pos_0 : œÉ p q r = .Collinear ‚Üî matrix_det p q r = 0 := by
  rw [œÉ, ofReal_eq_collinear]

theorem detIffHalfPlaneCCW : a ‚àà halfPlaneCCW p q ‚Üî matrix_det p q a ‚â• 0 := by
  simp [halfPlaneCCW, ptInsideHalfPlaneCCW]
  constructor
  ¬∑ rintro (h | h)
    ¬∑ exact le_of_lt $ œÉ_CCW_iff_pos_det.mp h
    ¬∑ exact le_of_eq $ symm $ œÉ_Co_iff_pos_0.mp h
  ¬∑ intro h
    rcases eq_or_lt_of_le h with (h | h)
    ¬∑ exact Or.inr $ œÉ_Co_iff_pos_0.mpr h.symm
    ¬∑ exact Or.inl $ œÉ_CCW_iff_pos_det.mpr h

theorem HalfPlanesAreConvex : Convex ‚Ñù (halfPlaneCCW p q) := by
  convert convex_halfspace_le (ùïú := ‚Ñù) (E := Point)
      (f := fun r => (q.y - p.y) * r.x + (p.x - q.x) * r.y) _ (p.x * q.y - p.y * q.x) using 1
  ¬∑ ext r
    simp only [detIffHalfPlaneCCW, matrix_det_eq_det_pts, Point.det,
      Matrix.vec2_dotProduct, PiLp.sub_apply, Set.mem_setOf_eq]
    simp (config := {singlePass := true}) [‚Üê sub_nonneg]; ring_nf
  constructor <;> intros <;> simp [Point.x, Point.y] <;> ring

theorem det_symmetry (a b c : Point) : matrix_det a b c = -matrix_det b a c := by
  rw [matrix_det_eq_det_pts]
  rw [matrix_det_eq_det_pts]
  unfold Point.det
  linarith

theorem det_symmetry' (a b c : Point) : matrix_det a b c = matrix_det b c a := by
  rw [matrix_det_eq_det_pts]
  rw [matrix_det_eq_det_pts]
  unfold Point.det
  linarith

theorem  det_antisymmetry (a b c : Point) : matrix_det a b c = -matrix_det b a c := by
  rw [matrix_det_eq_det_pts]
  rw [matrix_det_eq_det_pts]
  unfold Point.det
  linarith

theorem det_antisymmetry' (a b c : Point) : matrix_det a b c = -matrix_det a c b := by
  rw [matrix_det_eq_det_pts]
  rw [matrix_det_eq_det_pts]
  unfold Point.det
  linarith

theorem convex3combo (S : Set Point) (CS: Convex ‚Ñù S) :
    ‚àÄ (a b c : Point), a ‚àà S ‚Üí b ‚àà S ‚Üí c ‚àà S ‚Üí
      ‚àÄ (Œ± Œ≤ Œ≥ : ‚Ñù), Œ± + Œ≤ + Œ≥ = 1 ‚Üí Œ± ‚â• 0 ‚Üí Œ≤ ‚â• 0 ‚Üí Œ≥ ‚â• 0 ‚Üí
        Œ± ‚Ä¢ a + Œ≤ ‚Ä¢ b + Œ≥ ‚Ä¢ c ‚àà S := by
  intro a b c
  intro aS bS cS
  intro Œ± Œ≤ Œ≥
  intro sum1 Œ±NN Œ≤NN Œ≥NN
  by_cases case : Œ± + Œ≤ = 0
  {
    have Œ±0 : Œ± = 0 := by linarith
    have Œ≤0 : Œ≤ = 0 := by linarith
    have Œ≥1 : Œ≥ = 1 := by linarith
    rw [Œ±0, Œ≤0, Œ≥1]
    simp
    exact cS
  }
  {
    let Œ±' := Œ± / (Œ± + Œ≤)
    let Œ≤' := Œ≤ / (Œ± + Œ≤)
    have Œ±'NN : Œ±' ‚â• 0 := by
      apply div_nonneg; exact Œ±NN; linarith
    have Œ≤'NN : Œ≤' ‚â• 0 := by
      apply div_nonneg; exact Œ≤NN; linarith

    have Œ±Œ≤sum : Œ±' + Œ≤' = 1 := by
      rw [div_add_div_same]
      rw [div_self]
      exact case
    let combo := Œ±' ‚Ä¢ a + Œ≤' ‚Ä¢ b
    have comboInS : combo ‚àà S := by
      exact CS aS bS Œ±'NN Œ≤'NN Œ±Œ≤sum
    let fSum := Œ± + Œ≤
    have fSumNN : fSum ‚â• 0 := by {
     simp; linarith
    }
    have fSumŒ≥ : fSum + Œ≥ = 1 := by {
      rw [sum1]
    }
    let combo2 := fSum ‚Ä¢ combo + Œ≥ ‚Ä¢ c
    have combo2InS : combo2 ‚àà S := by
      exact CS comboInS cS fSumNN Œ≥NN fSumŒ≥

    have combo2Eq : combo2 = Œ± ‚Ä¢ a + Œ≤ ‚Ä¢ b + Œ≥ ‚Ä¢ c := by {
      simp only [smul_add, ‚Üê smul_assoc]
      have neq := Ne.symm case
      field_simp
      rw [mul_comm]
      rw [mul_div_assoc]
      rw [div_self]
      field_simp
      rw [mul_comm]
      rw [mul_div_assoc]
      rw [div_self]
      field_simp

      exact Ne.symm neq
      exact Ne.symm neq
    }
    rw [‚Üêcombo2Eq]
    exact combo2InS
  }

noncomputable def arProjX_p_q (a r : Point) : ‚Ñù :=
  (r.y * a.x - r.x * a.y) / (r.y - a.y)

theorem arProjX_between_p_q {a p q r : Point}
    (py0: p.y = 0) (qy0: q.y = 0)
    (det_qar_neg : matrix_det q a r < 0) (det_par_pos : matrix_det p a r > 0)
    (ar_y_order : r.y > a.y) :
    p.x <  (arProjX_p_q a r) ‚àß (arProjX_p_q a r) < q.x := by
  have order_aProjX_qX : (arProjX_p_q a r) < q.x := by {
     unfold arProjX_p_q
     suffices linearized: q.x * (r.y - a.y) > r.y * a.x - r.x * a.y by
     {
       simp at linearized
       rw [div_lt_iff']
       linarith
       linarith only [ar_y_order]
     }
     rw [matrix_det_eq_det_pts] at det_qar_neg
     unfold Point.det at det_qar_neg
     rw [qy0] at det_qar_neg
     simp at det_qar_neg
     linarith
  }

  have order_aProjX_pX : p.x < (arProjX_p_q a r) := by {
     unfold arProjX_p_q
     suffices linearized: p.x * (r.y - a.y) < r.y * a.x - r.x * a.y by
     {
       rw [lt_div_iff']
       linarith
       linarith only [ar_y_order]
     }
     rw [matrix_det_eq_det_pts] at det_par_pos
     unfold Point.det at det_par_pos
     rw [py0] at det_par_pos
     simp at det_par_pos
     linarith
  }
  exact ‚ü®order_aProjX_pX, order_aProjX_qX‚ü©

theorem convexComboOfCollinearAndXOrdered (p q x : Point) (collinear: matrix_det p q x = 0) (xOrder1: p.x < x.x) (xOrder2: x.x < q.x) :
    ‚àÉ (Œ± Œ≤ : ‚Ñù), Œ± + Œ≤ = 1 ‚àß Œ± ‚â• 0 ‚àß Œ≤ ‚â• 0 ‚àß Œ± ‚Ä¢ p + Œ≤ ‚Ä¢ q = x := by
  -- because they're on the same line and a is between their y coordinates
  let Œ± := (q.x - x.x) / (q.x - p.x)
  let Œ≤ := (x.x - p.x) / (q.x - p.x)
  use Œ±
  use Œ≤
  have Œ±Œ≤Sum : Œ± + Œ≤ = 1 := by {
    rw [div_add_div_same]
    simp
    rw [div_self]
    linarith
  }
  use Œ±Œ≤Sum
  have Œ±NN : Œ± ‚â• 0 := by {
    apply div_nonneg; linarith
    linarith
  }
  have Œ≤NN : Œ≤ ‚â• 0 := by {
    apply div_nonneg; linarith
    linarith
  }
  use Œ±NN
  use Œ≤NN
  simp
  rw [matrix_det_eq_det_pts] at collinear
  unfold Point.det at collinear
  have : q.x - p.x ‚â† 0 := by linarith
  ext

  field_simp [this]
  linarith [collinear]

  field_simp [this]
  linarith [collinear]

theorem convexComboOfCollinearAndYOrdered (p q x : Point) (collinear: matrix_det p q x = 0) (yOrder1: p.y < x.y) (yOrder2: x.y < q.y) :
    ‚àÉ (Œ± Œ≤ : ‚Ñù), Œ± + Œ≤ = 1 ‚àß Œ± ‚â• 0 ‚àß Œ≤ ‚â• 0 ‚àß Œ± ‚Ä¢ p + Œ≤ ‚Ä¢ q = x := by
  -- because they're on the same line and a is between their y coordinates
  let Œ± := (q.y - x.y) / (q.y - p.y)
  let Œ≤ := (x.y - p.y) / (q.y - p.y)
  use Œ±
  use Œ≤
  have Œ±Œ≤Sum : Œ± + Œ≤ = 1 := by {
    rw [div_add_div_same]
    simp
    rw [div_self]
    linarith
  }
  use Œ±Œ≤Sum
  have Œ±NN : Œ± ‚â• 0 := by {
    apply div_nonneg; linarith
    linarith
  }
  have Œ≤NN : Œ≤ ‚â• 0 := by {
    apply div_nonneg; linarith
    linarith
  }
  use Œ±NN
  use Œ≤NN
  simp
  rw [matrix_det_eq_det_pts] at collinear
  unfold Point.det at collinear
  have : q.y - p.y ‚â† 0 := by linarith
  ext

  field_simp [this]
  linarith [collinear]

  field_simp [this]
  linarith [collinear]

def IsConvexCombo‚ÇÇ (x p q : Point) : Prop :=
  ‚àÉ (Œ± Œ≤ : ‚Ñù), Œ± + Œ≤ = 1 ‚àß Œ± ‚â• 0 ‚àß Œ≤ ‚â• 0 ‚àß Œ± ‚Ä¢ p + Œ≤ ‚Ä¢ q = x

def IsConvexCombo‚ÇÉ (a p q r : Point) : Prop :=
  ‚àÉ (Œ± Œ≤ Œ≥ : ‚Ñù), Œ± + Œ≤ + Œ≥ = 1 ‚àß Œ± ‚â• 0 ‚àß Œ≤ ‚â• 0 ‚àß Œ≥ ‚â• 0 ‚àß Œ± ‚Ä¢ p + Œ≤ ‚Ä¢ q + Œ≥ ‚Ä¢ r = a

theorem convexComboTransitive {p q r a x: Point} :
    IsConvexCombo‚ÇÇ x p q ‚Üí IsConvexCombo‚ÇÇ a x r ‚Üí IsConvexCombo‚ÇÉ a p q r := by
  intro h‚ÇÅ h‚ÇÇ
  unfold IsConvexCombo‚ÇÇ at h‚ÇÅ h‚ÇÇ
  rcases h‚ÇÅ with ‚ü®Œ±‚ÇÅ, Œ≤‚ÇÅ, hŒ±Œ≤, hŒ±‚ÇÅ, hŒ≤‚ÇÅ, h_convex‚ÇÅ‚ü©
  rcases h‚ÇÇ with ‚ü®Œ±‚ÇÇ, Œ≤‚ÇÇ, hŒ±Œ≤‚ÇÇ, hŒ±‚ÇÇ, hŒ≤‚ÇÇ, h_convex‚ÇÇ‚ü©
  subst h_convex‚ÇÅ
  simp at h_convex‚ÇÇ
  unfold IsConvexCombo‚ÇÉ
  use Œ±‚ÇÇ ‚Ä¢ Œ±‚ÇÅ, Œ±‚ÇÇ ‚Ä¢ Œ≤‚ÇÅ, Œ≤‚ÇÇ
  constructor
  ¬∑ have h‚ÇÅ : Œ±‚ÇÇ * (Œ±‚ÇÅ + Œ≤‚ÇÅ) = Œ±‚ÇÇ * 1 := by
      exact congrArg (HMul.hMul Œ±‚ÇÇ) hŒ±Œ≤
    rw [mul_one] at h‚ÇÅ
    conv at h‚ÇÅ => rhs; rw [eq_sub_of_add_eq hŒ±Œ≤‚ÇÇ]
    replace h‚ÇÅ := add_eq_of_eq_sub h‚ÇÅ
    simp [mul_add] at h‚ÇÅ
    simp [h‚ÇÅ]
  ¬∑ simp only [smul_eq_mul, ge_iff_le]
    use smul_nonneg hŒ±‚ÇÇ hŒ±‚ÇÅ, mul_nonneg hŒ±‚ÇÇ hŒ≤‚ÇÅ, hŒ≤‚ÇÇ
    rwa [‚Üê smul_assoc, ‚Üê smul_assoc] at h_convex‚ÇÇ

theorem PtInTriangle_of_œÉPtInTriangle {a p q r : Point}
    (spq: p.x < q.x)
    (symm: œÉ p q r = Orientation.CCW) (py0: p.y = 0) (qy0: q.y = 0) :
    œÉPtInTriangle a p q r ‚Üí PtInTriangle a p q r  := by
  unfold PtInTriangle
  intro ‚ü®h1, h2, h3‚ü©
  have det_pqr_pos : matrix_det p q r > 0 := by {
    rw [œÉ_CCW_iff_pos_det] at symm
    linarith
  }
  have det_qpr_neg : matrix_det q p r < 0 := by {
    rw [det_antisymmetry] at det_pqr_pos
    linarith
  }

  have anti : œÉ p q r = - œÉ p r q := by {
    rw [œÉ_perm‚ÇÇ]
  }
  have : œÉ p a r = œÉ p q r := by {
    rw [œÉ_perm‚ÇÇ]
    rw [anti]
    simp [h2]
  }

  have det_qar_neg : matrix_det q a r < 0 := by {
    rw [‚ÜêœÉ_CW_iff_neg_det]
    rw [‚ÜêœÉ_CW_iff_neg_det] at det_qpr_neg
    rw [œÉ_perm‚ÇÇ] at h3
    have: œÉ q r p = - œÉ q a r := by {
      aesop
    }
    rw [œÉ_perm‚ÇÇ] at this
    simp at this
    aesop
  }

  have det_par_pos : matrix_det p a r > 0 := by {
    rw [œÉ_perm‚ÇÇ] at h2
    rw [‚ÜêœÉ_CCW_iff_pos_det]
    aesop
  }

  let aProjXPt : Point := ![(arProjX_p_q a r), 0]

  have pqa_pos : matrix_det p q a > 0 := by {

    have : œÉ p q a = Orientation.CCW := by {
      rw [h1]
      exact symm
    }
    rw [œÉ_CCW_iff_pos_det] at this
    exact this
  }
  have y_order : aProjXPt.y = 0 ‚àß a.y > 0 ‚àß r.y > a.y := by {
    use rfl
    constructor
    . rw [matrix_det_eq_det_pts] at pqa_pos
      unfold Point.det at pqa_pos
      rw [py0, qy0] at pqa_pos
      simp at pqa_pos
      nlinarith
    . rw [matrix_det_eq_det_pts] at det_par_pos
      rw [matrix_det_eq_det_pts] at det_qar_neg
      unfold Point.det at det_par_pos
      unfold Point.det at det_qar_neg
      rw [py0] at det_par_pos
      rw [qy0] at det_qar_neg
      simp at det_par_pos
      simp at det_qar_neg
      nlinarith
  }

  have arProjX_bet_p_q := arProjX_between_p_q py0 qy0 det_qar_neg det_par_pos y_order.2.2

  have arProjXPt_p_q_XOrdered : p.x < aProjXPt.x ‚àß aProjXPt.x < q.x := by {
    exact arProjX_bet_p_q
  }

  have p_q_arProjXPt_collinear : matrix_det p q aProjXPt = 0 := by {
    rw [matrix_det_eq_det_pts]
    unfold Point.det
    rw [py0, qy0]
    simp
  }

  have aProjXPt_IsConvexCombOf_p_q :=
    convexComboOfCollinearAndXOrdered p q aProjXPt p_q_arProjXPt_collinear arProjXPt_p_q_XOrdered.1 arProjXPt_p_q_XOrdered.2


  have aProjX_r_a_collinear : matrix_det aProjXPt r a = 0 := by {
    rw [matrix_det_eq_det_pts]
    unfold Point.det
    dsimp
    unfold arProjX_p_q
    have : r.y - a.y ‚â† 0 := by linarith
    apply mul_right_cancel‚ÇÄ (b := r.y - a.y) this
    field_simp [this]
    ring
  }

  have a_IsConvexCombOf_aProjXPt_r :=
      convexComboOfCollinearAndYOrdered aProjXPt r a aProjX_r_a_collinear y_order.2.1 y_order.2.2

  have a_IsConvexCombOf_p_q_r :
    ‚àÉ (Œ± Œ≤ Œ≥ : ‚Ñù), Œ± + Œ≤ + Œ≥ = 1 ‚àß Œ± ‚â• 0 ‚àß Œ≤ ‚â• 0 ‚àß Œ≥ ‚â• 0 ‚àß Œ± ‚Ä¢ p + Œ≤ ‚Ä¢ q + Œ≥ ‚Ä¢ r = a := by {
      exact convexComboTransitive aProjXPt_IsConvexCombOf_p_q a_IsConvexCombOf_aProjXPt_r
    }

  have cHullIsConvex: Convex ‚Ñù (convexHull ‚Ñù {p , q, r}) := by {
    exact convex_convexHull ‚Ñù {p , q, r}
  }

  have sSetHull : {p, q, r} ‚äÜ convexHull ‚Ñù {p , q, r} := by {
    exact subset_convexHull ‚Ñù {p , q, r}
  }

  have pInChull : p ‚àà convexHull ‚Ñù {p , q, r} := by {
    rw [Set.subset_def] at sSetHull
    simp at sSetHull
    exact sSetHull.1
  }
  have qInChull : q ‚àà convexHull ‚Ñù {p , q, r} := by {
    rw [Set.subset_def] at sSetHull
    simp at sSetHull
    exact sSetHull.2.1
  }
  have rInChull : r ‚àà convexHull ‚Ñù {p , q, r} := by {
    rw [Set.subset_def] at sSetHull
    simp at sSetHull
    exact sSetHull.2.2
  }

  have ‚ü®Œ±, Œ≤, Œ≥, Œ±Œ≤Œ≥Sum, Œ±NN, Œ≤NN, Œ≥NN, ccEq‚ü© := a_IsConvexCombOf_p_q_r
  have c3c := convex3combo (convexHull ‚Ñù {p, q, r}) cHullIsConvex p q r  pInChull qInChull rInChull
  have := c3c Œ± Œ≤ Œ≥ Œ±Œ≤Œ≥Sum Œ±NN Œ≤NN Œ≥NN
  rw [ccEq] at this
  exact this

theorem œÉPtInTriangle_of_PtInTriangle {a p q r : Point} (gp : Point.InGeneralPosition‚ÇÑ a p q r)
    (symm: œÉ p q r = Orientation.CCW) :
    PtInTriangle a p q r ‚Üí œÉPtInTriangle a p q r := by
  intro h
  unfold PtInTriangle at h
  unfold œÉPtInTriangle
  let halfPlanePQ := halfPlaneCCW p q
  let halfPlaneQR := halfPlaneCCW q r
  let halfPlaneRP := halfPlaneCCW r p
  have pInPQ: p ‚àà halfPlanePQ := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }
  have pInRP: p ‚àà halfPlaneRP := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }
  have pInQR: p ‚àà halfPlaneQR := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [œÉ_CCW_iff_pos_det] at symm
      rw [‚Üêdet_symmetry']
      linarith
    }
  have qInPQ: q ‚àà halfPlanePQ := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }
  have qInQR: q ‚àà halfPlaneQR := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }
  have qInRP: q ‚àà halfPlaneRP := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [œÉ_CCW_iff_pos_det] at symm
      rw [det_symmetry']
      linarith
    }

  have rInPQ: r ‚àà halfPlanePQ := by
    {
      simp
      rw [detIffHalfPlaneCCW]
      rw [œÉ_CCW_iff_pos_det] at symm
      linarith
    }
  have rInQR: r ‚àà halfPlaneQR := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }
  have rInRP: r ‚àà halfPlaneRP := by
    {
      simp; rw [detIffHalfPlaneCCW]
      rw [matrix_det_eq_det_pts]; unfold Point.det
      linarith
    }

  let inter := halfPlanePQ ‚à© (halfPlaneQR ‚à© halfPlaneRP)
  have pInter: p ‚àà inter := Set.mem_inter pInPQ (Set.mem_inter pInQR pInRP)
  have qInter: q ‚àà inter := Set.mem_inter qInPQ (Set.mem_inter qInQR qInRP)
  have rInter: r ‚àà inter := Set.mem_inter rInPQ (Set.mem_inter rInQR rInRP)

  have cRP: Convex ‚Ñù (halfPlaneRP) := by exact HalfPlanesAreConvex
  have cPQ: Convex ‚Ñù (halfPlanePQ) := by exact HalfPlanesAreConvex
  have cQR: Convex ‚Ñù (halfPlaneQR) := by exact HalfPlanesAreConvex
  have interConvex : Convex ‚Ñù inter := by exact Convex.inter cPQ (Convex.inter cQR cRP)

  have sub_set_inter : {p, q, r} ‚äÜ inter := by
  {
      simp_rw [Set.subset_def]
      simp; exact ‚ü®pInter, ‚ü®qInter, rInter‚ü©‚ü©
  }

  have aInInter: a ‚àà inter := by
    {
      unfold convexHull at h
      simp at h
      apply h inter sub_set_inter interConvex
    }

  have aInHalfPQ: a ‚àà halfPlanePQ := by aesop
  have aInHalfRP: a ‚àà halfPlaneRP := by aesop
  have aInHalfQR: a ‚àà halfPlaneQR := by aesop

  have pqa_non_0 : matrix_det p q a ‚â† 0 := by
    {
      have l := gp.1
      unfold Point.InGeneralPosition‚ÇÉ at l
      rw [‚Üêmatrix_det_eq_det_pts] at l
      rw [det_symmetry'] at l
      exact l
    }
  have pra_non_0 : matrix_det p r a ‚â† 0 := by
    {
      have l := gp.2
      unfold Point.InGeneralPosition‚ÇÉ at l
      rw [‚Üêmatrix_det_eq_det_pts] at l
      rw [det_symmetry'] at l
      exact l
    }
  have qra_non_0 : matrix_det q r a ‚â† 0 := by
    {
      have l := gp.3
      unfold Point.InGeneralPosition‚ÇÉ at l
      rw [‚Üêmatrix_det_eq_det_pts] at l
      rw [det_symmetry'] at l
      exact l
    }

  have pqr_pos : matrix_det p q r > 0 := by
    {
      rw [œÉ_CCW_iff_pos_det] at symm
      linarith
    }

  have pqa_CCW : œÉ p q a = Orientation.CCW := by
    {
      rw [detIffHalfPlaneCCW] at aInHalfPQ
      rw [œÉ_CCW_iff_pos_det]
      apply lt_of_le_of_ne aInHalfPQ (Ne.symm pqa_non_0)
    }
  have goal1: œÉ p q a = œÉ p q r := Eq.trans pqa_CCW (Eq.symm symm)
  use goal1

  have pra_neg : matrix_det p r a < 0 := by
      {
        apply lt_of_le_of_ne
        rw [detIffHalfPlaneCCW] at aInHalfRP
        rw [det_antisymmetry] at aInHalfRP
        linarith
        exact pra_non_0
      }
  have prq_neg : matrix_det p r q < 0 := by
      {
        rw [det_antisymmetry'] at pqr_pos
        linarith
      }
  have goal2: œÉ p r a = œÉ p r q := by
    {
      rw [‚ÜêœÉ_CW_iff_neg_det] at pra_neg
      rw [‚ÜêœÉ_CW_iff_neg_det] at prq_neg
      aesop
    }
  use goal2

  have qrp_pos : matrix_det q r p > 0 := by
    {
      rw [‚Üêdet_symmetry']; exact pqr_pos
    }
  have qra_pos : matrix_det q r a > 0 := by
    {
      rw [detIffHalfPlaneCCW] at aInHalfQR
      apply lt_of_le_of_ne aInHalfQR (Ne.symm qra_non_0)
    }
  rw [‚ÜêœÉ_CCW_iff_pos_det] at qrp_pos
  rw [‚ÜêœÉ_CCW_iff_pos_det] at qra_pos
  exact Eq.trans qra_pos (Eq.symm qrp_pos)

theorem PtInTriangleInvariantUnderTransform {a p q r : Point}  (t : Point) (Œ∏ : ‚Ñù) :
    PtInTriangle a p q r ‚Üî PtInTriangle (rotateTranslateMap Œ∏ t a) (rotateTranslateMap Œ∏ t p) (rotateTranslateMap Œ∏ t q) (rotateTranslateMap Œ∏ t r) := by
  unfold PtInTriangle
  have := AffineMap.image_convexHull {p,q,r} (rotateTranslateMap Œ∏ t)
  simp [Set.image_insert_eq] at this
  rw [‚Üê this]
  set S := convexHull ‚Ñù {p,q,r}
  symm
  apply Function.Injective.mem_set_image
  exact injective_rotateTranslateMap Œ∏ t

theorem rotateTranslatePreserveœÉ (Œ∏ : ‚Ñù) (t p q r : Point) :
    œÉ p q r = œÉ (rotateTranslateMap Œ∏ t p) (rotateTranslateMap Œ∏ t q) (rotateTranslateMap Œ∏ t r) := by
  rw [rotateTranslateTransform]
  rw [rotateTranslateTransform]
  rw [rotateTranslateTransform]
  set T := (translation_matrix (Point.x t) (Point.y t) * Matrix.rotateByAffine Œ∏)
  have : TMatrix T := by exact rotateTranslateTMatrix Œ∏ t
  symm
  apply TMatrix.pt_transform_preserves_sigma p q r this

theorem œÉPtInTriangleInvariantUnderTransform {a p q r : Point}  (t : Point) (Œ∏ : ‚Ñù) :
    œÉPtInTriangle a p q r ‚Üî œÉPtInTriangle (rotateTranslateMap Œ∏ t a) (rotateTranslateMap Œ∏ t p) (rotateTranslateMap Œ∏ t q) (rotateTranslateMap Œ∏ t r) := by
  unfold œÉPtInTriangle
  rw [‚ÜêrotateTranslatePreserveœÉ]
  rw [‚ÜêrotateTranslatePreserveœÉ]
  rw [‚ÜêrotateTranslatePreserveœÉ]
  rw [‚ÜêrotateTranslatePreserveœÉ]
  rw [‚ÜêrotateTranslatePreserveœÉ]
  rw [‚ÜêrotateTranslatePreserveœÉ]

theorem extraPiDoesntChange0y (Œ∏ : ‚Ñù)  (p : Point) :
    (rotationMap Œ∏ p).y = 0 ‚Üî (rotationMap (Œ∏ + Real.pi) p).y = 0 := by
  apply Iff.intro
  {
    intro h
    simp at *
    linarith
  }
  {
    intro h
    simp at *
    linarith
  }

lemma translate_to_0_change (p t: Point) : (translateMap t p).y = 0 ‚Üî p.y + t.y = 0 := by
  rw [translateMap_apply]
  simp
  constructor
  . intro h; linarith
  . intro h; linarith

theorem extraPiDoesntChange0y' (Œ∏ : ‚Ñù)  (p : Point) :
    (rotateTranslateMap Œ∏ ![0, -(rotationMap Œ∏ p).y] p).y = 0 ‚Üî ((rotateTranslateMap (Œ∏ + Real.pi) ![0, -(rotationMap (Œ∏ + Real.pi) p).y]) p).y = 0 := by
  apply Iff.intro
  {
    unfold rotateTranslateMap
    intro h
    simp at *
    rw [translate_to_0_change] at h
    rw [translate_to_0_change]
    simp
    simp at h
    linarith
  }
  {
    unfold rotateTranslateMap
    intro h
    simp at *
    rw [translate_to_0_change] at h
    rw [translate_to_0_change]
    simp
    simp at h
    linarith
  }

theorem existsNiceRotTrans {p q : Point} (diff: p ‚â† q): ‚àÉ (Œ∏ : ‚Ñù) (t : Point),
      (rotateTranslateMap Œ∏ t p).y = 0
    ‚àß (rotateTranslateMap Œ∏ t q).y = 0
    ‚àß (rotateTranslateMap Œ∏ t p).x < (rotateTranslateMap Œ∏ t q).x := by
  by_cases same_x : p.x = q.x
  {
    by_cases p_above_q: p.y > q.y
    {
      use Real.pi/2
      let p' := rotationMap (Real.pi/2) p
      let q' := rotationMap (Real.pi/2) q
      use ![0, -p'.y]
      constructor
      . unfold rotateTranslateMap
        simp
        rw [translateMap_apply]
        simp

      . constructor
        . have same_y' : p'.y = q'.y := by {
            simp
            assumption
          }
          rw [same_y']
          unfold rotateTranslateMap
          simp
          rw [translateMap_apply]
          simp
        . unfold rotateTranslateMap
          simp
          rw [translateMap_apply]
          rw [translateMap_apply]
          simp
          ring_nf
          linarith
    }
    {
      have p_below_q: p.y < q.y := by {
        by_contra C
        have same_y : p.y = q.y := by
        {
          exact _root_.le_antisymm (le_of_not_gt p_above_q) (le_of_not_gt C)
        }
        refine diff.elim ?_
        ext <;> assumption
      }

      use -(Real.pi/2)
      let p' := rotationMap (-(Real.pi/2)) p
      let q' := rotationMap (-(Real.pi/2)) q
      use ![0, -p'.y]
      constructor
      . unfold rotateTranslateMap
        simp
        rw [translateMap_apply]
        simp
      . constructor
        . have same_y' : p'.y = q'.y := by {
            simp
            assumption
          }
          rw [same_y']
          unfold rotateTranslateMap
          simp
          rw [translateMap_apply]
          simp
        . unfold rotateTranslateMap
          simp
          rw [translateMap_apply]
          rw [translateMap_apply]
          simp
          ring_nf
          linarith
    }
  }
  {
    obtain ‚ü®S, eq‚ü©: ‚àÉ x, x = (q.y - p.y) / (q.x - p.x) := ‚ü®_, rfl‚ü©
    let Œ∏ := -Real.arctan (S)
    let p' := rotationMap Œ∏ p
    let t := ![0, -p'.y]

    have rpy0 : (rotateTranslateMap Œ∏ t p).y = 0 := by {
      unfold rotateTranslateMap
      simp
      rw [translateMap_apply]
      simp
      ring_nf
    }

    have rqy0 : (rotateTranslateMap Œ∏ t q).y = 0 := by {
      unfold rotateTranslateMap
      simp
      rw [translateMap_apply]
      simp
      rw [Real.sin_arctan]
      rw [Real.cos_arctan]
      calc -(1 / Real.sqrt (1 + S ^ 2) * Point.y p) + S / Real.sqrt (1 + S ^ 2) * Point.x p
          + (-(S / Real.sqrt (1 + S ^ 2) * Point.x q) + 1 / Real.sqrt (1 + S ^ 2) * Point.y q)
        _  = (1 / Real.sqrt (1 + S ^ 2))*(-Point.y p + Point.y q) + S / Real.sqrt (1 + S ^ 2) * Point.x p
          + (-(S / Real.sqrt (1 + S ^ 2) * Point.x q)) := by ring_nf
        _  =  (1 / Real.sqrt (1 + S ^ 2))*(-Point.y p + Point.y q) + (S / Real.sqrt (1 + S ^ 2) * (Point.x p - Point.x q)) := by ring_nf
        _  =  ((Point.y q - Point.y p)  - (S* (q.x - p.x))) / Real.sqrt (1 + S ^ 2) := by ring_nf
        _  =  ((Point.y q - Point.y p)  - ((q.y - p.y) / (q.x - p.x) * (q.x - p.x))) / Real.sqrt (1 + ((q.y - p.y) / (q.x - p.x) ) ^ 2) := by rw [eq]
        _  = 0 :=  by field_simp [(sub_ne_zero.2 same_x)]; rw [@mul_div_cancel _ _ _ _ (sub_ne_zero.2 (Ne.symm same_x))]; simp
    }

    have post_neq : (rotateTranslateMap Œ∏ t p).x ‚â† (rotateTranslateMap Œ∏ t q).x := by {
      have prev :  (rotateTranslateMap Œ∏ t p).y = (rotateTranslateMap Œ∏ t q).y := by linarith
      have injc :  (rotateTranslateMap Œ∏ t p) ‚â† (rotateTranslateMap Œ∏ t q) := by {
          intro pq
          apply diff
          apply injective_rotateTranslateMap _ _ pq
        }
      intro pxqx
      apply injc (Point.ext pxqx prev)
    }

    by_cases post_lt : (rotateTranslateMap Œ∏ t p).x < (rotateTranslateMap Œ∏ t q).x
    {
      use Œ∏, t
    }
    {
      rw [not_lt] at post_lt
      have : (rotateTranslateMap Œ∏ t q).x < (rotateTranslateMap Œ∏ t p).x := by apply lt_of_le_of_ne; exact post_lt; exact (Ne.symm post_neq)
      let Œ∏' := Œ∏ + Real.pi
      let p'' := rotationMap Œ∏' p

      let t'' := ![0, -p''.y]
      use Œ∏', t''
      have g1: (rotateTranslateMap Œ∏' t'' p).y = 0 := by {
        unfold rotateTranslateMap
        simp
        rw [translateMap_apply]
        simp
        ring_nf
      }
      have g2: (rotateTranslateMap Œ∏' t'' q).y = 0 := by {
        unfold rotateTranslateMap
        simp
        rw [translateMap_apply]
        simp
        rw [Real.sin_arctan, Real.cos_arctan]
        field_simp
        calc Point.y p + -(S * Point.x p) + (S * Point.x q + -Point.y q)
          _ = Point.y p + -S * Point.x p + S * Point.x q + -Point.y q := by ring_nf
          _ = Point.y p + S * (Point.x q - Point.x p) + -Point.y q := by ring_nf
          _ = (Point.y p - Point.y q) + S * (Point.x q - Point.x p) := by ring_nf
          _ = (Point.y p - Point.y q) + ((Point.y q - Point.y p) / (Point.x q - Point.x p)) * (Point.x q - Point.x p) := by rw [eq]
          _ = 0 := by field_simp [(sub_ne_zero.2 same_x)]; rw [@mul_div_cancel _ _ _ _ (sub_ne_zero.2 (Ne.symm same_x))]; simp
      }
      have g3: (rotateTranslateMap Œ∏' t'' p).x < (rotateTranslateMap Œ∏' t'' q).x := by {
        unfold rotateTranslateMap
        simp
        rw [translateMap_apply, translateMap_apply]
        simp
        unfold rotateTranslateMap at this
        simp at this
        rw [translateMap_apply, translateMap_apply] at this
        simp at this
        nlinarith
      }
      exact ‚ü®g1, g2, g3‚ü©
    }
  }

theorem PtInTriangle_of_œÉPtInTriangle' {a p q r : Point} (gp : Point.InGeneralPosition‚ÇÑ a p q r)
    (symm: œÉ p q r = Orientation.CCW) :
    œÉPtInTriangle a p q r ‚Üí PtInTriangle a p q r  := by
  intro h
  have p_neq_q : p ‚â† q := by {
    have l := gp.4
    unfold Point.InGeneralPosition‚ÇÉ at l
    unfold Point.det at l
    by_contra C
    simp [C] at l
    ring_nf at l
    tauto
  }

  have ‚ü®Œ∏, t, h1, h2, h3‚ü© := existsNiceRotTrans p_neq_q
  set p' := rotateTranslateMap Œ∏ t p
  set q' := rotateTranslateMap Œ∏ t q
  set r' := rotateTranslateMap Œ∏ t r
  set a' := rotateTranslateMap Œ∏ t a
  have a'inTri : œÉPtInTriangle a' p' q' r' := by {
    rw [‚Üê œÉPtInTriangleInvariantUnderTransform]
    exact h
  }
  have symm' : œÉ p' q' r' = Orientation.CCW := by {
     rw [‚ÜêrotateTranslatePreserveœÉ]
     exact symm
  }
  have := PtInTriangle_of_œÉPtInTriangle h3 symm' h1 h2 a'inTri
  rw [‚ÜêPtInTriangleInvariantUnderTransform] at this
  exact this

theorem œÉPtInTriangle_iff_of_CCW {a p q r : Point} (gp : Point.InGeneralPosition‚ÇÑ a p q r)
    (symm: œÉ p q r = Orientation.CCW) :
    œÉPtInTriangle a p q r ‚Üî PtInTriangle a p q r := by
  apply Iff.intro
  exact PtInTriangle_of_œÉPtInTriangle' gp symm
  exact œÉPtInTriangle_of_PtInTriangle gp symm

theorem œÉPtInTriangle_iff {a p q r : Point} (gp : Point.InGeneralPosition‚ÇÑ a p q r) :
    œÉPtInTriangle a p q r ‚Üî PtInTriangle a p q r := by
  rcases gp.gp‚ÇÑ.œÉ_cases with h | h
  . exact œÉPtInTriangle_iff_of_CCW gp h
  . have hccw : œÉ p r q = .CCW := by rw [œÉ_perm‚ÇÇ, h]; rfl
    have : InGeneralPosition‚ÇÑ a p r q := ‚ü®gp.gp‚ÇÇ, gp.gp‚ÇÅ, gp.gp‚ÇÉ.perm‚ÇÇ, gp.gp‚ÇÑ.perm‚ÇÇ‚ü©
    have := œÉPtInTriangle_iff_of_CCW this hccw
    exact ‚ü®
      fun h => PtInTriangle.perm‚ÇÇ (this.mp (œÉPtInTriangle.perm‚ÇÇ h)),
      fun h => œÉPtInTriangle.perm‚ÇÇ (this.mpr (PtInTriangle.perm‚ÇÇ h))‚ü©

-- TODO(WN): Think we can cut the stuff below
#exit

def HasEmptyTriangle (pts : List Point) : Prop :=
  ‚àÉ p q r, Sublist [p, q, r] pts ‚àß ‚àÄ a ‚àà pts, a ‚àâ ({p, q, r} : Set Point) ‚Üí ¬¨PtInTriangle a p q r

def œÉHasEmptyTriangle (pts : List Point) : Prop :=
  ‚àÉ p q r, Sublist [p, q, r] pts ‚àß ‚àÄ a ‚àà pts, a ‚àâ ({p, q, r} : Set Point) ‚Üí ¬¨œÉPtInTriangle a p q r

def œÉHasEmptyTriangle2 (pts : List Point) : Prop :=
  ‚àÉ i j k : (Fin pts.length),  (i < j ‚àß j < k) ‚àß ‚àÄ a: (Fin pts.length), a ‚àâ ({i , j, k} : Set (Fin pts.length))  ‚Üí ¬¨(œÉPtInTriangle2 pts[a] pts[i] pts[j] pts[k])


infix:50 " ~_œÉ " => œÉ_equivalence
def OrientationProperty (P : List Point ‚Üí Prop) :=
  ‚àÄ l‚ÇÅ l‚ÇÇ, (Point.PointListInGeneralPosition l‚ÇÅ ‚àß Point.PointListInGeneralPosition l‚ÇÇ)  ‚Üí  l‚ÇÅ ~_œÉ l‚ÇÇ ‚Üí (P l‚ÇÅ ‚Üî P l‚ÇÇ)

theorem OrientationProperty.not : OrientationProperty P ‚Üí OrientationProperty (¬¨P ¬∑) := by
  unfold OrientationProperty
  intro h l‚ÇÅ l‚ÇÇ hœÉ
  simp [h l‚ÇÅ l‚ÇÇ hœÉ]
  have := h l‚ÇÅ l‚ÇÇ hœÉ
  aesop


theorem œÉHasEmptyTriangle_iff_œÉHasEmptyTriangle2 {pts : List Point} (gp : Point.PointListInGeneralPosition pts) :
    œÉHasEmptyTriangle pts ‚Üî œÉHasEmptyTriangle2 pts := by
  unfold œÉHasEmptyTriangle œÉHasEmptyTriangle2
  sorry -- obvious, TODO WN

theorem œÉHasEmptyTriangle_iff {pts : List Point} (gp : Point.PointListInGeneralPosition pts) :
    œÉHasEmptyTriangle2 pts ‚Üî HasEmptyTriangle pts := by
  unfold œÉHasEmptyTriangle2 HasEmptyTriangle
  sorry -- obvious, TODO WN

theorem OrientationProperty_œÉHasEmptyTriangle : OrientationProperty œÉHasEmptyTriangle := by
  unfold OrientationProperty
  intro l‚ÇÅ l‚ÇÇ gps h

  rw [œÉHasEmptyTriangle_iff_œÉHasEmptyTriangle2]
  rw [œÉHasEmptyTriangle_iff_œÉHasEmptyTriangle2]

  unfold œÉHasEmptyTriangle2

  apply Iff.intro
  {
    intro he

    have ‚ü®p, q, r, h'‚ü© := he
    unfold œÉPtInTriangle2 at h'
    unfold œÉPtInTriangle2

    rcases h with ‚ü®sameLength,sameOrientations‚ü©

    -- p' is a copy of p but of type (Fin l‚ÇÇ.length)
    rcases p with ‚ü®p, p_lt‚ü©
    rcases q with ‚ü®q, q_lt‚ü©
    rcases r with ‚ü®r, r_lt‚ü©

    use ‚ü®p, by linarith‚ü©, ‚ü®q, by linarith‚ü©, ‚ü®r, by linarith‚ü©
    simp

    rcases h' with ‚ü®h'1, h'2‚ü©
    apply And.intro

    simp at h'1
    exact h'1

    intro a
    intro ha
    rcases a with ‚ü®a, a_lt‚ü©
    have h2a := h'2 ‚ü®a, by linarith‚ü©
    simp at ha
    simp at h2a
    have rh2a := h2a ha
    simp at rh2a
    have Hpqr := sameOrientations p_lt q_lt r_lt
    have alt1 : a < l‚ÇÅ.length := by linarith
    have Hpqa := sameOrientations p_lt q_lt alt1
    have Hpra := sameOrientations p_lt r_lt alt1
    have Hqra := sameOrientations q_lt r_lt alt1
    have Hprq := sameOrientations p_lt r_lt q_lt
    have Hqrp := sameOrientations q_lt r_lt p_lt
    rw [‚ÜêHpqr, ‚ÜêHpqa, ‚ÜêHpra, ‚ÜêHqra, ‚ÜêHprq, ‚ÜêHqrp]

    exact rh2a
  }
  {
    intro he

    have ‚ü®p, q, r, h'‚ü© := he
    unfold œÉPtInTriangle2 at h'
    unfold œÉPtInTriangle2

    rcases h with ‚ü®sameLength,sameOrientations‚ü©

    -- p' is a copy of p but of type (Fin l‚ÇÇ.length)
    rcases p with ‚ü®p, p_lt‚ü©
    rcases q with ‚ü®q, q_lt‚ü©
    rcases r with ‚ü®r, r_lt‚ü©

    use ‚ü®p, by linarith‚ü©, ‚ü®q, by linarith‚ü©, ‚ü®r, by linarith‚ü©
    simp

    rcases h' with ‚ü®h'1, h'2‚ü©
    apply And.intro

    simp at h'1
    exact h'1

    intro a
    intro ha
    rcases a with ‚ü®a, a_lt‚ü©
    have h2a := h'2 ‚ü®a, by linarith‚ü©
    simp at ha
    simp at h2a
    have rh2a := h2a ha
    simp at rh2a
    rw [‚ÜêsameLength] at p_lt q_lt r_lt
    have Hpqr := sameOrientations p_lt q_lt r_lt
    have alt1 : a < l‚ÇÅ.length := by linarith
    have Hpqa := sameOrientations p_lt q_lt alt1
    have Hpra := sameOrientations p_lt r_lt alt1
    have Hqra := sameOrientations q_lt r_lt alt1
    have Hprq := sameOrientations p_lt r_lt q_lt
    have Hqrp := sameOrientations q_lt r_lt p_lt
    rw [Hpqr, Hpqa, Hpra, Hqra, Hprq, Hqrp]

    exact rh2a
  }
  exact gps.2
  exact gps.1
