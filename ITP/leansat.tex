This section describes the bridge between mathematical objects and the propositional variables representing them in the context of a CNF formula. 
Consider the following theorem: 

\begin{lstlisting}
theorem EmptyTriangle10TheoremLists 
    (pts : List Point) (gp : PtListInGP pts) (h : pts.length = 10) :
    HasEmptyTriangle pts.toFinset
\end{lstlisting}

% We wish to prove that no list of $10$ points in general position can avoid an empty triangle.
% Consider the propositional formula $\varphi$ over variables $\orvar_{p, q, r}$, with $1 \leq p  < q < r \leq 10$.  
% \begin{enumerate}
%     % \item $\left(\neg \orvar_{p, q, r} \lor \neg \orvar_{p, r, t} \lor \orvar_{p, q, t}\right) \land \left(\orvar_{p, q, r} \lor \orvar_{p, r, t} \lor  \neg \orvar_{p, q, t}\right)$  
%     % &\left(\neg \orvar_{p, q, r} \lor \neg \orvar_{q, r, t} \lor  \orvar_{p, r, t}\right) \land \left(\orvar_{p, q, r} \lor \orvar_{q, r, t} \lor  \neg \orvar_{p, r, t}\right).
% \end{enumerate}





% Describe how we go from abstract formula over boolean variables
% to a CNF using encoding programs.
% CNF is usually large, and SAT solvers take the CNF in a format called DIMACS which is not human inspectable.
% Thus usually generated by encoding program rather than constructed manually.
% This DIMACS is fed to a SAT solver, which produces an UNSAT certificate
% (usually in a format known as DRAT or LRAT).

% Given this pipeline, we have two distinct concerns for correctness:
% \begin{itemize}
%     \item[(1)] \textbf{Is the CNF formula correct?}    
%     We want to formally verify that our ``encoder'' program
%     generates DIMACS output which
%     correctly represent the abstract formula we wish to show UNSAT.
%     \item[(2)] \textbf{Is the SAT solver output correct?}
%     The UNSAT certificate must be checked for correctness
%     against the DIMACS formula.
% \end{itemize}

% Prior work on (2) has produced highly trustworthy proof checkers
% for SAT solver output (cake lpr citation, GRAT citation maybe?).
% We rely on \texttt{cake\_lpr} for this step of the proof,
% and trust that the DIMACS formula given to \texttt{cake\_lpr}
% is unsatisfiable if this program terminates without error.

% In contrast, we found very little prior work on (1).
% Codel (cite Codel, any other papers Cayden found about this).

% We built on (bryant citation, codel citation)
% to develop tools for writing correct-by-construction encoding programs
% against an abstract model of propositional formulas.
% This infrastructure is a component of the fledgling \leansat{} library,
% which is largely outside the scope of this paper.
% Nonetheless this library enabled us to re-implement
% Heule et al's encoding exactly as presented (TODO: is this true?).

% Here we give a brief overview of how this section of the formalization proceeds.

% \subsection{Variables}

% The \leansat{} library allows formulas to be written over arbitrary variable sets.
% As an example, for the Empty Triangle Theorem (see section 5) we use the following variables:
% \begin{lstlisting}
% inductive Var (n : Nat)
%   | sigma  (a b c : Fin n)
%   | inside (x a b c : Fin n)
%   | hole   (a b c : Fin n)
% \end{lstlisting}
% TODO explain how the library handles converting these variables to \(\mathbb{N}\)
% for the purposes of DIMACS.

% \subsection{Abstract Propositional Formula}

% Given that the encoding presented in Heule et al has many sets of clauses,
% we divide the abstract formula into a few sub-formulas.
% Here is the formula which defines the "is hole" variables:
% \begin{lstlisting}
% /--
%   Triangle abc is a hole iff all x are not inside triangle abc.
% -/
% def holeDefs (n : Nat) : PropAssignment (Var n) → Prop := fun τ =>
%   ∀ {a b c}, τ (Var.hole a b c) ↔
%     (∀ x, a < x → x < c → x ≠ b →
%       !τ (Var.inside x a b c))
% \end{lstlisting}
% The Lean statement here is clean and simple,
% and nicely corresponds to the paper presentation.
% We define the entire formula in around 100 lines of Lean.
% TODO(JG): get exact numbers

% \subsection{Encoding Program}

% Now that we have defined an abstract formula over our variables,
% we need to write a program which encodes this formula to DIMACS.
% Again we divide the program into sub-programs,
% corresponding exactly to how we divided up the formula.
% Here is the signature of the encoder for the formula from the previous section:
% \begin{lstlisting}
% def holeDefClauses (n : Nat) : VEncCNF (Var n) Unit (holeDefs n) :=
%   ...
% \end{lstlisting}
% The \texttt{VEncCNF} type is essentially a state monad,
% where the state is the DIMACS output.
% However, it is constrained to those programs which
% verifiably encode the predicate \texttt{holeDefs n}.

% In particular, if we run \texttt{holeDefClauses n},
% we get DIMACS output which is satisfiable iff \texttt{holeDefs n} is satisfiable,
% no matter what the particulars are in \texttt{holeDefClauses}.
% This is expressed in the following theorem from \leansat{}:
% \begin{lstlisting}
% theorem toICnf_equisatisfiable [FinEnum ν] (v : VEncCNF L α P) :
%   (∃ τ : PropAssignment IVar, τ |= v.val.toICnf.toPropFun) ↔
%     (∃ τ : PropAssignment ν, P τ)
% \end{lstlisting}
% TODO(JG): cleanup in leansat

% The encoding program, and its verification,
% takes a few hundred lines of Lean.
% TODO(JG) update when done rewriting

% \subsection{Verifying UNSAT Proof}

% We have generated a DIMACS-format formula which is satisfiable iff
% our abstract encoding is satisfiable.
% Ideally, at this point we would emit the formula,
% run a SAT solver,
% get a proof of unsatisfiability,
% and then check this proof \textit{in the trusted Lean kernel}.
% This approach would establish the formula unsatisfiable
% with the same level of trust as all mathematics verified in Lean.

% Unfortunately, such an approach is not feasible due to performance constraints.
% The Lean kernel is simple and trustworthy,
% but evaluates programs quite slowly,
% orders of magnitude slower than executing compiled Lean programs.
% The \(h(6) = 30\) result generated on the order of 100 TB of DRAT proof,
% which is far, far beyond the range at which the kernel could feasibly check.

% TODO(JG): explain our new trust story for this last leg of the journey.

% \begin{lstlisting}
% axiom cnfUnsat : ¬∃ τ, τ |= (theEncoding 30).toICNF
% \end{lstlisting}
% TODO(JG): make this statement reality
