Even though mathematicians are often skeptical of proofs relying on extensive computation (e.g., the four color theorem~\cite{Walters2004ItAT}),
many mathematically-interesting theorems have been resolved that way. In the last decade, SAT-solving has shown to be a very powerful tool for mathematics, successfully resolving
Keller's conjecture~\cite{brakensiek2023resolution},
the packing chromatic number of the infinite grid~\cite{Subercaseaux_Heule_2023},
the Pythagorean triples problem~\cite{Heule_2016},
Lam's problem~\cite{21bright_sat_based_resolution_lams_problem},
and one case of the Erd\H{o}s discrepancy conjecture~\cite{konev2014sat}.
All of these proofs rely on the same two-step structure:
\begin{itemize}
\item \textbf{(Reduction)} Show that the mathematical theorem of interest is true if a concrete CNF formula $F$ is unsatisfiable.
\item \textbf{(Solving)} Show that $F$ is indeed unsatisfiable.
\end{itemize}

% \footnote{A variant of this procedure uses \emph{satisfying assignments} for $P$ to construct explicit witnesses for the original theorem, but we focus on the unsatisfiable case.}
% \end{itemize}

Formal methods researchers have devoted significant attention to making the \emph{solving} step reliable, reproducible and trustworthy. That is, to ensure that when a SAT-solver declares a formula $F$ to be unsatisfiable, the formula is indeed unsatisfiable.
Modern SAT solvers produce proofs of unsatisfiability in formal systems
such as DRAT~\cite{drat-trim14},
that can in turn be checked with verified proof checkers,
such as \texttt{cake\_lpr}~\cite{tanVerifiedPropagationRedundancy2023}. 
On the other hand, the \emph{reduction} step can hardly be addressed through general tools, since reductions are often highly problem-specific and require deep mathematical insights.
It is therefore the reduction step that poses the greatest challenge to the trustworthiness of SAT-based proofs in mathematics. 
% The correctness of the \emph{reduction} step, however, has received 
% leaving room for doubt that any results relying on such reduction arguments are correct.

A recent breakthrough from Heule and Scheucher~\cite{emptyHexagonNumber} in discrete computational geometry is a perfect example of the complexity of reducing mathematical theorems to propositional formulas that can be solved efficiently. Indeed, they constructed (and solved) a formula $F$ whose unsatisfiability implies that every set of 30 points, without three in a common line, must contain an empty convex hexagon.
However, as it is common in such results, their reduction argument was only sketched, relying heavily on intuition, and leaving several gaps to be filled.
 

% result from Heule and Scheucher~\cite{emptyHexagonNumber} falls into this category.
% They resolve a variant of the Happy Ending Problem,
% in particular that every set of 30 points in general position contains an empty convex hexagon.
% Their proof relies on a complicated reduction to SAT
% involving numerous nontrivial geometric optimizations and symmetry-breaking arguments.

In this paper we complete and formalize the reduction of Heule and Scheucher in the Lean theorem prover~\cite{demouraLeanTheoremProver2015}.\footnote{Our formalization is publicly available at \url{https://github.com/bsubercaseaux/EmptyHexagonLean}.}
We do so by connecting existing geometric definitions
in the \texttt{mathlib} mathematical proof library~\cite{The_mathlib_Community_2020}
to the unsatisfiability of a particular SAT instance, thus setting a new standard for verifying results which rely on extensive computation.



\subparagraph*{The Empty Hexagon Number.}
In the 1930s,
following a suggestion of Esther Klein,
Erd\H{o}s and Szekeres showed that for any $k \geq 3$,
one can find a sufficiently large number $n$
such that every $n$ points in \emph{general position}
(i.e., with no three points collinear)
contain a convex \emph{$k$-gon}, i.e., a convex polygon with $k$ vertices~\cite{35erdos_combinatorial_problem_geometry}.
The minimal such $n$ is denoted $g(k)$.
The same authors later showed that $g(k) > 2^{k-2}$
and conjectured that this bound is tight~\cite{60erdos_some_extremum_problems_elementary_geometry}.
Indeed, it is known that $g(5) = 9$ and $g(6) = 17$,
with the latter result obtained by Szekeres and Peters 71 years after the initial conjecture
via exhaustive computer search~\cite{06szekeres_computer_solution_17_point_erdos_szekeres_problem}.
Larger cases remain open,
with $g(k) \leq 2^{k+o(k)}$ the best known upper bound~\cite{suk2017erdos,holmsen2017two}.
This problem is now known as the \emph{Happy Ending Problem},
as it led to the marriage of Klein and Szekeres.

In a similar spirit,
Erd\H{o}s defined $h(k)$
to be the minimal number of points in general position
that is guaranteed to contain a \emph{$k$-hole},
or \emph{empty $k$-gon},
meaning a convex $k$-gon with no other point inside.
It is easy to check that $h(3) = 3$ and $h(4) = 5$.
In 1978, Harborth established that $h(5) = 10$~\cite{Harborth1978}.
Surprisingly, for $k \geq 7$ a point set with no $k$-hole
can always be constructed
as demonstrated by Horton in 1983~\cite{hortonSetsNoEmpty1983}.
The only case left open was thus $h(6)$.
The \emph{Empty Hexagon Theorem},
establishing $h(6)$ to be finite,
was proven independently by Gerken and Nicolás in 2006~\cite{gerkenEmptyConvexHexagons2008,nicolasEmptyHexagonTheorem2007}.
As of last year,
the known range of values for $h(6)$ was quite large,
at $30 \leq h(6) \leq 1717$
as refined by Valtr in 2008~\cite{valtr},
until a breakthrough by Heule and Scheucher~\cite{emptyHexagonNumber}.
These authors used a SAT solver
to prove that $h(6) \leq 30$,
a result we refer to as the \emph{Empty Hexagon Number}.
Now that all the values of $h$ are known,
and especially given the extensive computation involved in its proofs,
we propose that the final chapter in the story
should be a formal verification of the Empty Hexagon Number.

\subparagraph*{Verification of SAT proofs.}
Formal verification plays a crucial role in the SAT community,
for example in verified solvers~\cite{10maric_formal_verification_modern_sat_solver_shallow_embedding_isabelle_hol,oeVersatVerifiedModern2012,skotam_creusat_2022}
and proof checking~\cite{lammichEfficientVerifiedSAT2020,tanVerifiedPropagationRedundancy2023}.
Despite this,
not many mathematical proofs obtained through SAT-solving
have been formally verified.

In SAT-based combinatorial geometry,
formal verification was pioneered by Marić~\cite{19maric_fast_formal_proof_erdos_szekeres_conjecture_convex_polygons_most_six_points}
who improved on the speed needed to obtain $g(6) = 17$,
and trustworthiness of this result,
by replacing bespoke code with a SAT encoding
and verifying this encoding in \textsf{Isabelle/HOL}.
We give a detailed comparison between this work and ours in~\Cref{sec:related-work}.
The solution to the Pythagorean triples problem
was verified in the \textsf{Coq} proof assistant
by Cruz-Filipe and coauthors~\cite{formalPythagoreanTriples,LPAR-21:Formally_Proving_Boolean_Pythagorean}.
Giljeg\r{a}rd and Wennerbreck~\cite{GilAndWennerbeck} provide a \textsf{CakeML} library
for verified SAT encodings
which they demonstrated on different puzzles
(e.g., Sudoku, Kakuro, the \emph{N-queens} problem).
As far as verifying SAT encodings in Lean,
we base our work on that of Codel, Avigad, and Heule~\cite{Cayden}.

\subparagraph*{Lean.}
Initially developed by Leonardo de Moura in 2013~\cite{demouraLeanTheoremProver2015}, the Lean theorem prover has arguably become the most popular theorem prover for formalizing modern breakthroughs in mathematical research.
On the one hand, the recent success of projects such as the~\emph{Liquid Tensor Experiment}~\cite{Castelvecchi2021}, or the proof of~the polynomial Freiman–Ruzsa conjecture~\cite{gowers2023conjecture, slomanATeamMathProves2023} has brought significant attention to~Lean. % as an interactive theorem prover.
On the the other hand, the \textsf{mathlib} project~\cite{The_mathlib_Community_2020} has already cemented the foundations of many areas of mathematics, thus allowing modern results to be formalized much more easily by relying on hundreds of thousands of existing lines of code. In this spirit, we connect our formalization to~\textsf{mathlib} as much as possible.

% \subparagraph*{Mathlib.}
% % TODO


